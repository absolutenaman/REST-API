
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>db: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">rest-api/db/db.go (0.0%)</option>
				
				<option value="file1">rest-api/main.go (0.0%)</option>
				
				<option value="file2">rest-api/middlewares/auth.go (0.0%)</option>
				
				<option value="file3">rest-api/mocks/mock_events.go (53.3%)</option>
				
				<option value="file4">rest-api/mocks/mock_user.go (100.0%)</option>
				
				<option value="file5">rest-api/models/events.go (0.0%)</option>
				
				<option value="file6">rest-api/models/registration.go (0.0%)</option>
				
				<option value="file7">rest-api/models/user.go (0.0%)</option>
				
				<option value="file8">rest-api/router/events.go (21.7%)</option>
				
				<option value="file9">rest-api/router/registration.go (0.0%)</option>
				
				<option value="file10">rest-api/router/routes.go (0.0%)</option>
				
				<option value="file11">rest-api/router/user.go (100.0%)</option>
				
				<option value="file12">rest-api/utils/jwt.go (0.0%)</option>
				
				<option value="file13">rest-api/utils/utils.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package db

import (
        "database/sql"
        _ "github.com/mattn/go-sqlite3"
)

var DB *sql.DB
var err error

func InitDB() <span class="cov0" title="0">{
        DB, err = sql.Open("sqlite3", "api.DB")
        if err != nil </span><span class="cov0" title="0">{
                panic("DB connection successful")</span>
        }
        <span class="cov0" title="0">DB.SetMaxOpenConns(10)
        DB.SetMaxIdleConns(5)
        createTable()</span>

}
func createTable() <span class="cov0" title="0">{
        createUsersTable := `CREATE TABLE IF NOT EXISTS users  (
     id          INTEGER PRIMARY KEY AUTOINCREMENT,
    email        TEXT NOT NULL UNIQUE,
    password TEXT NOT NULL 
)`
        _, err := DB.Exec(createUsersTable)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">createTableQuery := `CREATE TABLE IF NOT EXISTS events  (
     id         INTEGER PRIMARY KEY AUTOINCREMENT,
    name        TEXT NOT NULL ,
    description TEXT NOT NULL ,
    location    TEXT NOT NULL ,
    dateTime    DATETIME NOT NULL ,
    userId INTEGER NOT NULL ,
    FOREIGN KEY(userId) REFERENCES users(id)
)`

        _, err = DB.Exec(createTableQuery)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "github.com/gin-gonic/gin"
        "rest-api/db"
        "rest-api/router"
)

func main() <span class="cov0" title="0">{
        db.InitDB()
        server := gin.Default()
        router.RouterInitialisation(server)
        err := server.Run("localhost:8080")
        
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package middlewares

import (
        "github.com/gin-gonic/gin"
        "net/http"
        "rest-api/utils"
)

func Authenticate(context *gin.Context) <span class="cov0" title="0">{
        token := context.Request.Header.Get("Authorization")
        if token == "" </span><span class="cov0" title="0">{
                context.JSON(http.StatusUnauthorized, gin.H{"message": "User not authorized to create an event"})
                return
        }</span>
        <span class="cov0" title="0">userId, err := utils.ValidateToken(token)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusUnauthorized, gin.H{"message": "User not authorized to create an event"})
                return
        }</span>
        <span class="cov0" title="0">context.Set("userId", userId)
        context.Next()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: events.go

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"
        models "rest-api/models"

        gomock "github.com/golang/mock/gomock"
)

// MockEventsService is a mock of EventsService interface.
type MockEventsService struct {
        ctrl     *gomock.Controller
        recorder *MockEventsServiceMockRecorder
}

// MockEventsServiceMockRecorder is the mock recorder for MockEventsService.
type MockEventsServiceMockRecorder struct {
        mock *MockEventsService
}

// NewMockEventsService creates a new mock instance.
func NewMockEventsService(ctrl *gomock.Controller) *MockEventsService <span class="cov8" title="1">{
        mock := &amp;MockEventsService{ctrl: ctrl}
        mock.recorder = &amp;MockEventsServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventsService) EXPECT() *MockEventsServiceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// GetAllEventsById mocks base method.
func (m *MockEventsService) GetAllEventsById(id int64) (models.Events, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllEventsById", id)
        ret0, _ := ret[0].(models.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllEventsById indicates an expected call of GetAllEventsById.
func (mr *MockEventsServiceMockRecorder) GetAllEventsById(id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllEventsById", reflect.TypeOf((*MockEventsService)(nil).GetAllEventsById), id)
}</span>

// Save mocks base method.
func (m *MockEventsService) Save(events models.Events) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Save", events)
}</span>

// Save indicates an expected call of Save.
func (mr *MockEventsServiceMockRecorder) Save(events interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockEventsService)(nil).Save), events)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: user.go

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"
        models "rest-api/models"

        gomock "github.com/golang/mock/gomock"
)

// MockUserService is a mock of UserService interface.
type MockUserService struct {
        ctrl     *gomock.Controller
        recorder *MockUserServiceMockRecorder
}

// MockUserServiceMockRecorder is the mock recorder for MockUserService.
type MockUserServiceMockRecorder struct {
        mock *MockUserService
}

// NewMockUserService creates a new mock instance.
func NewMockUserService(ctrl *gomock.Controller) *MockUserService <span class="cov8" title="1">{
        mock := &amp;MockUserService{ctrl: ctrl}
        mock.recorder = &amp;MockUserServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserService) EXPECT() *MockUserServiceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AddUser mocks base method.
func (m *MockUserService) AddUser(user *models.User) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddUser", user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddUser indicates an expected call of AddUser.
func (mr *MockUserServiceMockRecorder) AddUser(user interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddUser", reflect.TypeOf((*MockUserService)(nil).AddUser), user)
}</span>

// ValidateUser mocks base method.
func (m *MockUserService) ValidateUser(user *models.User) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ValidateUser", user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ValidateUser indicates an expected call of ValidateUser.
func (mr *MockUserServiceMockRecorder) ValidateUser(user interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateUser", reflect.TypeOf((*MockUserService)(nil).ValidateUser), user)
}</span>

// MockUtil is a mock of Util interface.
type MockUtil struct {
        ctrl     *gomock.Controller
        recorder *MockUtilMockRecorder
}

// MockUtilMockRecorder is the mock recorder for MockUtil.
type MockUtilMockRecorder struct {
        mock *MockUtil
}

// NewMockUtil creates a new mock instance.
func NewMockUtil(ctrl *gomock.Controller) *MockUtil <span class="cov8" title="1">{
        mock := &amp;MockUtil{ctrl: ctrl}
        mock.recorder = &amp;MockUtilMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUtil) EXPECT() *MockUtilMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// TokenGeneration mocks base method.
func (m *MockUtil) TokenGeneration(email string, id int64) (string, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "TokenGeneration", email, id)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// TokenGeneration indicates an expected call of TokenGeneration.
func (mr *MockUtilMockRecorder) TokenGeneration(email, id interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TokenGeneration", reflect.TypeOf((*MockUtil)(nil).TokenGeneration), email, id)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        DB "rest-api/db"
        "time"
)

type Events struct {
        ID          int64     `json:"id"`
        Name        string    `json:"name" binding:"required"`
        Description string    `json:"description" binding:"required"`
        Location    string    `json:"location" binding:"required"`
        DateTime    time.Time `json:"dateTime"`
        User        int64     `json:"user"`
}

var arr []Events

func GetAllEvents() []Events <span class="cov0" title="0">{
        rows, err := DB.DB.Query(`SELECT * FROM events`)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                var event Events
                err := rows.Scan(&amp;event.ID, &amp;event.Name, &amp;event.Description, &amp;event.Location, &amp;event.DateTime, &amp;event.User)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">arr = append(arr, event)</span>
        }
        <span class="cov0" title="0">defer rows.Close()
        return arr</span>
}
func (e *Events) Sava() <span class="cov0" title="0">{
        insertQuery := `INSERT INTO events (name,description,location,dateTime,userId) VALUES (?,?,?,?,?)`
        res, err := DB.DB.Exec(insertQuery, e.Name, e.Description, e.Location, e.DateTime, e.User)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">e.ID, _ = res.LastInsertId()</span>
}

// in case of post request that will be a struct method
// incase of get request it will be a function
func GetAllEventsById(id int64) (Events, error) <span class="cov0" title="0">{
        selectQuery := `SELECT * FROM events WHERE ID =(?)`
        rows := DB.DB.QueryRow(selectQuery, id)
        var e Events
        err := rows.Scan(&amp;e.ID, &amp;e.Name, &amp;e.Description, &amp;e.Location, &amp;e.DateTime, &amp;e.User)
        if err != nil </span><span class="cov0" title="0">{
                return e, err
        }</span>
        <span class="cov0" title="0">return e, nil</span>
}
func (e *Events) UpdateEvent() error <span class="cov0" title="0">{
        query := `UPDATE events SET name=?,description=?,location=?,dateTime=? WHERE id=?`
        _, err := DB.DB.Exec(query, e.Name, e.Description, e.Location, e.DateTime, e.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (e *Events) DeleteEvent() error <span class="cov0" title="0">{
        query := `DELETE FROM EVENTS WHERE id=?`
        _, err := DB.DB.Exec(query, e.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package models

import "rest-api/db"

type Registrations struct {
        id      int64 `json:"id"`
        userId  int64 `json:"userId"`
        eventId int64 `json:"eventId"`
}

func Register(userId, eventId int64) error <span class="cov0" title="0">{
        query := `INSERT INTO registrations (userId,eventId)  VALUES (?,?)`
        _, err := db.DB.Exec(query, userId, eventId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func Cancellation(userId, eventId int64) error <span class="cov0" title="0">{
        query := `DELETE FROM registrations WHERE userId=? AND eventId=?`
        _, err := db.DB.Exec(query, userId, eventId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package models

import (
        "errors"
        "fmt"
        "rest-api/db"
        "rest-api/utils"
)

type User struct {
        Id       int64  `json:"id"`
        Email    string `binding:"required" json:"email"`
        Password string `binding:"required" json:"password"`
}

func (u *User) AddUser() error <span class="cov0" title="0">{
        addQuery := `INSERT INTO users (email,password) VALUES (?,?)`
        hashedPassword, err := utils.HashPassword(u.Password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">resultedRow, err := db.DB.Exec(addQuery, u.Email, hashedPassword)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">u.Id, _ = resultedRow.LastInsertId()
        return nil</span>
}
func (u *User) ValidateUser() error <span class="cov0" title="0">{
        getUserQuery := `SELECT * FROM users WHERE EMAIL=?`
        row, err := db.DB.Query(getUserQuery, u.Email)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("err1", err)
                return err
        }</span>
        <span class="cov0" title="0">var user User
        for row.Next() </span><span class="cov0" title="0">{
                err = row.Scan(&amp;user.Id, &amp;user.Email, &amp;user.Password)
        }</span>
        <span class="cov0" title="0">u.Id = user.Id
        if user.Password == "" </span><span class="cov0" title="0">{
                return errors.New("failed")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Println("err2", err)
                return err
        }</span>
        <span class="cov0" title="0">_, err = utils.ValidatePassword([]byte(user.Password), []byte(u.Password))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("err3", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package router

import (
        "github.com/gin-gonic/gin"
        "net/http"
        "rest-api/models"
        "strconv"
)

//go:generate mockgen -source=events.go -destination=../mocks/mock_events.go -package=mocks
type EventsService interface {
        GetAllEventsById(id int64) (models.Events, error)
        Save(events models.Events)
}
type EventsHandler struct {
        eventsService EventsService
}

func NewEventsHandler(service EventsService) *EventsHandler <span class="cov8" title="1">{
        return &amp;EventsHandler{
                eventsService: service,
        }
}</span>
func getEvents(context *gin.Context) <span class="cov0" title="0">{
        events := models.GetAllEvents()
        context.JSON(http.StatusOK, events)
}</span>
func (h *EventsHandler) getEvent(context *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(context.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusInternalServerError, gin.H{"err": err})
        }</span>
        <span class="cov0" title="0">allEventsByTheId, err := h.eventsService.GetAllEventsById(id)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusInternalServerError, gin.H{"err": err})
        }</span>
        <span class="cov0" title="0">context.JSON(http.StatusOK, allEventsByTheId)</span>
}
func (h *EventsHandler) createEvent(context *gin.Context) <span class="cov8" title="1">{
        userId := context.GetInt64("userId")
        var event models.Events
        err := context.ShouldBindJSON(&amp;event)
        event.User = userId
        if err != nil </span><span class="cov8" title="1">{
                context.JSON(http.StatusBadRequest, gin.H{"message": "Bad Request"})
                return
        }</span>
        <span class="cov8" title="1">h.eventsService.Save(event)
        context.JSON(http.StatusOK, gin.H{"message": "Event created succesfully", "event": event})</span>
}

func (h *EventsHandler) updateEvent(context *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(context.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusInternalServerError, gin.H{"err": err})
        }</span>
        <span class="cov0" title="0">allEventByTheId, err := h.eventsService.GetAllEventsById(id)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusInternalServerError, gin.H{"err": err})
        }</span>
        <span class="cov0" title="0">var updatedEvent models.Events

        updatedEvent.ID = allEventByTheId.ID
        err = context.ShouldBindJSON(&amp;updatedEvent)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusInternalServerError, gin.H{"err": err})
        }</span>
        <span class="cov0" title="0">err = updatedEvent.UpdateEvent()
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusInternalServerError, gin.H{"err": err})
        }</span>
        <span class="cov0" title="0">context.JSON(http.StatusOK, gin.H{"message": "Event updated successfully"})</span>
}
func (h *EventsHandler) deleteEvent(context *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(context.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusInternalServerError, gin.H{"err": err})
        }</span>
        <span class="cov0" title="0">allEventByTheId, err := h.eventsService.GetAllEventsById(id)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusInternalServerError, gin.H{"err": err})
        }</span>
        <span class="cov0" title="0">var deletedEventId models.Events
        deletedEventId.ID = allEventByTheId.ID
        err = deletedEventId.DeleteEvent()
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusInternalServerError, gin.H{"err": err})
        }</span>
        <span class="cov0" title="0">context.JSON(http.StatusOK, gin.H{"message": "Event deleted successfully"})</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package router

import (
        "github.com/gin-gonic/gin"
        "net/http"
        "rest-api/models"
        "strconv"
)

func registerForEvent(context *gin.Context) <span class="cov0" title="0">{
        eventId := context.Param("id")
        EventIdInInt, err := strconv.ParseInt(eventId, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusInternalServerError, gin.H{"Error": err})
                return
        }</span>
        <span class="cov0" title="0">_, err = models.GetAllEventsById(EventIdInInt)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusBadRequest, gin.H{"Message": "Invalid event Id"})
                return
        }</span>
        <span class="cov0" title="0">userId := context.GetInt64("userId")
        err = models.Register(userId, EventIdInInt)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusInternalServerError, gin.H{"Message": "Not able to insert the row in registrations table"})
                return
        }</span>
        <span class="cov0" title="0">context.JSON(http.StatusCreated, gin.H{"Message": "User Registered for event successfully"})</span>
}
func cancellationForEvent(context *gin.Context) <span class="cov0" title="0">{
        eventId := context.Param("id")
        EventIdInInt, err := strconv.ParseInt(eventId, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusInternalServerError, gin.H{"Error": err})
                return
        }</span>
        <span class="cov0" title="0">userId := context.GetInt64("userId")
        err = models.Cancellation(userId, EventIdInInt)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusInternalServerError, gin.H{"Message": "Error while executing the delete query"})
                return
        }</span>
        <span class="cov0" title="0">context.JSON(http.StatusOK, gin.H{"Message": "The registered event has been deleted successfully"})</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package router

import (
        "github.com/gin-gonic/gin"
        "rest-api/middlewares"
        "rest-api/models"
        "rest-api/utils"
)

type UserServiceImpl struct{}

func (s *UserServiceImpl) AddUser(user *models.User) error <span class="cov0" title="0">{
        return user.AddUser()
}</span>
func (s *UserServiceImpl) ValidateUser(user *models.User) error <span class="cov0" title="0">{
        return user.ValidateUser()
}</span>

type UtilImpl struct {
}

func (u *UtilImpl) TokenGeneration(email string, id int64) (string, error) <span class="cov0" title="0">{
        return utils.TokenGeneration(email, id)
}</span>

type EventsImpl struct {
}

func (e *EventsImpl) GetAllEventsById(id int64) (models.Events, error) <span class="cov0" title="0">{
        return models.GetAllEventsById(id)
}</span>
func (e *EventsImpl) Save(event models.Events) <span class="cov0" title="0">{
        event.Sava()
}</span>

func RouterInitialisation(server *gin.Engine) <span class="cov0" title="0">{
        eventsService := &amp;EventsImpl{}
        userService := &amp;UserServiceImpl{}
        utilService := &amp;UtilImpl{}
        h := NewUserHandler(userService, utilService)
        e := NewEventsHandler(eventsService)
        authenticate := server.Group("/")
        authenticate.Use(middlewares.Authenticate)
        authenticate.POST("/events", e.createEvent)
        authenticate.PUT("/events/:id", e.updateEvent)
        authenticate.DELETE("/events/:id", e.deleteEvent)
        authenticate.POST("/events/:id/register", registerForEvent)
        authenticate.DELETE("/events/:id/register", cancellationForEvent)
        server.Handle("GET", "/events", getEvents)
        server.Handle("GET", "/events/:id", e.getEvent)
        server.Handle("POST", "/signup", h.SignUp)
        server.Handle("POST", "/login", h.Login)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package router

import (
        "github.com/gin-gonic/gin"
        "net/http"
        "rest-api/models"
)

//go:generate mockgen -source=user.go -destination=../mocks/mock_user.go -package=mocks

type UserService interface {
        AddUser(user *models.User) error
        ValidateUser(user *models.User) error
}
type Util interface {
        TokenGeneration(email string, id int64) (string, error)
}
type UserHandler struct {
        userService UserService
        util        Util
}

func NewUserHandler(service UserService, util Util) *UserHandler <span class="cov8" title="1">{
        return &amp;UserHandler{
                userService: service,
                util:        util,
        }
}</span>

func (h *UserHandler) SignUp(ctx *gin.Context) <span class="cov8" title="1">{
        var u models.User
        err := ctx.ShouldBindJSON(&amp;u)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, gin.H{"message": "Bad request"})
        }</span>
        <span class="cov8" title="1">err = h.userService.AddUser(&amp;u)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"message": "Bad request"})
        }</span>
        <span class="cov8" title="1">ctx.JSON(http.StatusCreated, u)</span>
}
func (h *UserHandler) Login(ctx *gin.Context) <span class="cov8" title="1">{
        var u models.User
        err := ctx.ShouldBindJSON(&amp;u)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, gin.H{"message": "Bad request"})
        }</span>
        <span class="cov8" title="1">err = h.userService.ValidateUser(&amp;u)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusUnauthorized, gin.H{"message": "Invalid credentials"})
                return
        }</span>
        <span class="cov8" title="1">token, err := h.util.TokenGeneration(u.Email, u.Id)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"message": "Invalid credentials"})
                return
        }</span>
        <span class="cov8" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "Logged In Successfully"})
        ctx.JSON(http.StatusOK, gin.H{"token": token})</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package utils

import (
        "errors"
        "github.com/golang-jwt/jwt/v5"
        "time"
)

const secretKey = "6ccb75192751c56d05f870c92b4b644548286fd0edd72d41e98c5b1d7710008e"

func TokenGeneration(email string, id int64) (string, error) <span class="cov0" title="0">{
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "email": email,
                "id":    id,
                "exp":   time.Now().Add(time.Hour * 2).Unix(),
        })
        signedString, err := token.SignedString([]byte(secretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return signedString, nil</span>
}
func ValidateToken(token string) (int64, error) <span class="cov0" title="0">{
        parsedToken, err := jwt.Parse(token, func(token *jwt.Token) (any, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("unexpected signing method for token creation")
                }</span>
                <span class="cov0" title="0">return []byte(secretKey), nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, errors.New("could not parse token")
        }</span>
        <span class="cov0" title="0">if !parsedToken.Valid </span><span class="cov0" title="0">{
                return 0, errors.New("token validation failed")
        }</span>

        <span class="cov0" title="0">claims, ok := parsedToken.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return 0, errors.New("invalid token claims")
        }</span>

        <span class="cov0" title="0">idFloat, ok := claims["id"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return 0, errors.New("id not found or invalid type in claims")
        }</span>
        <span class="cov0" title="0">return int64(idFloat), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package utils

import "golang.org/x/crypto/bcrypt"

func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        hashedPasswordInByteForm, err := bcrypt.GenerateFromPassword([]byte(password), 8)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(hashedPasswordInByteForm), nil</span>
}
func ValidatePassword(hashedPassword, userEnteredPassword []byte) (bool, error) <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword(hashedPassword, userEnteredPassword)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
